(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{151:function(_,v,t){_.exports=t.p+"assets/img/tcpbw.150f8455.jpg"},152:function(_,v,t){_.exports=t.p+"assets/img/scws.281eb906.jpg"},153:function(_,v,t){_.exports=t.p+"assets/img/schs.afd93e7d.jpg"},215:function(_,v,t){"use strict";t.r(v);var a=t(0),e=Object(a.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"tcp-三次握手-四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手-四次挥手"}},[_._v("#")]),_._v(" TCP 三次握手 & 四次挥手")]),_._v(" "),a("p",[_._v("TCP 位于传输层，提供可靠的字节流服务。")]),_._v(" "),a("blockquote",[a("p",[_._v("可靠的字节流服务：TCP 协议为了传输方便，将大块数据分割成以"),a("code",[_._v("报文段（segment）")]),_._v("为单位的数据包进行管理，并能够把这些数据准确可靠的传递给对方。")])]),_._v(" "),a("h2",{attrs:{id:"tcp报文段格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp报文段格式"}},[_._v("#")]),_._v(" TCP报文段格式")]),_._v(" "),a("p",[_._v("下面是一张 TCP 报文格式的图片：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(151),alt:"TCP报文段格式"}})]),_._v(" "),a("p",[_._v("其中，几个比较重要的字段如下：")]),_._v(" "),a("h3",{attrs:{id:"序号和确认号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#序号和确认号"}},[_._v("#")]),_._v(" 序号和确认号")]),_._v(" "),a("p",[_._v("每个 TCP 报文内都有序号和确认号，结合重传机制保障数据传输的可靠性")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("seq 序号：TCP 连接字节流中每一个字节都会有一个编号，当建立连接的时候，TCP 选定一个初始序号（随机数），之后每发送一个数据包（消息），就将\n"),a("code",[_._v("序号+1")]),_._v("，保证每发送不同的数据包，数据包的序号都是不同的")])]),_._v(" "),a("li",[a("p",[_._v("ack 确认号：表示希望收到的下一个报文段部分的第一个字节的序号是 "),a("code",[_._v("seq+1")]),_._v("，以前的字节已经收到过了，ACK标志位被设置为1的时候，才会发送ack确认号。")])])]),_._v(" "),a("h3",{attrs:{id:"_6个标志位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6个标志位"}},[_._v("#")]),_._v(" 6个标志位")]),_._v(" "),a("p",[_._v("TCP 报文共有6个标志位，每个占1位，共6位，每一位的值只有0和1")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("SYN：同步标志位，SYN=1 时，表示这是一个连接请求报文")])]),_._v(" "),a("li",[a("p",[_._v("ACK：确认标志位，ACK=1 时，表示确认号有效，当 TCP 发送 ACK 时，相当于返回结果，需要带有确认序号，以便跟发送的消息对应起来。")])]),_._v(" "),a("li",[a("p",[_._v("FIN：终止标志位，FIN=1 时，表示此报文段的发送方数据已发送完毕，要求释放 TCP 连接")])]),_._v(" "),a("li",[a("p",[_._v("PSH：推送标志位，PSH=1 时表示该段报文高优先级，接收方应尽快推送给应用程序，而不用等整个 TCP 缓存都填满了在交付")])]),_._v(" "),a("li",[a("p",[_._v("URG：紧急标志位，URG=1 时表示紧急指针有效，此报文中有紧急数据要尽快传送，不需要按照原来的排列顺序来传送")])]),_._v(" "),a("li",[a("p",[_._v("RST：复位标志位，RST=1 时表示 TCP 连接中出现错误，需要释放并重新建立连接")])])]),_._v(" "),a("h2",{attrs:{id:"建立-tcp-连接：三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建立-tcp-连接：三次握手"}},[_._v("#")]),_._v(" 建立 TCP 连接：三次握手")]),_._v(" "),a("p",[_._v("TCP 连接的建立采用客户-服务器模式，主动发起连接建立的应用进程叫做客户，被动等待连接建立的应用进程叫做服务器，以下是建立 TCP 连接的过程：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(152),alt:"TCP三次握手"}})]),_._v(" "),a("h3",{attrs:{id:"第一次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一次握手"}},[_._v("#")]),_._v(" 第一次握手")]),_._v(" "),a("p",[_._v("客户端向服务端发送"),a("code",[_._v("请求连接")]),_._v("报文，将报文"),a("code",[_._v("同步标志位 SYN 的值设置为1")]),_._v("，表示要创建连接，等待服务器确认，并进入"),a("code",[_._v("SYN_SENT")]),_._v("状态。"),a("code",[_._v("（报文首部：SYN=1， 初始序号 seq=x（x为随机生成数值））")])]),_._v(" "),a("h3",{attrs:{id:"第二次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二次握手"}},[_._v("#")]),_._v(" 第二次握手")]),_._v(" "),a("p",[_._v("服务端接收到客户端的请求，回复给客户端确认报文，将报文"),a("code",[_._v("确认标志位 ACK 的值设置为1")]),_._v("，告诉客户端已收到它的请求，同意创建连接，并进入"),a("code",[_._v("SYN_RECV")]),_._v("状态。"),a("code",[_._v("（ACK=1，确认号 ack=x+1，SYN=1，初始序号 seq=y）")])]),_._v(" "),a("h3",{attrs:{id:"第三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三次握手"}},[_._v("#")]),_._v(" 第三次握手")]),_._v(" "),a("p",[_._v("客户端接收到服务端的确认报文之后，为了防止意外，再次向服务端发出确认报文，将报文"),a("code",[_._v("ACK 的值设置为1")]),_._v("，当服务端收到客户端发来的确认报文之后，TCP 连接建立，客户端和服务端都进入"),a("code",[_._v("ESTABLISHED")]),_._v("状态，完成三次握手，以后就可以开森的传递数据了。"),a("code",[_._v("（报文首部：ACK=1, 确认号 ack=y+1, 序号 seq=x+1（服务端传过来的ack的值）")])]),_._v(" "),a("h2",{attrs:{id:"断开-tcp-连接：四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#断开-tcp-连接：四次挥手"}},[_._v("#")]),_._v(" 断开 TCP 连接：四次挥手")]),_._v(" "),a("p",[_._v("由于 TCP 连接是"),a("code",[_._v("双工")]),_._v("的，因此每个方向都必须单独进行关闭。当一方完成它的数据发送任务后就可以发送一个"),a("code",[_._v("FIN")]),_._v("终止标志位来终止这个方向上的连接，"),a("code",[_._v("收到一个FIN")]),_._v("就意味着"),a("code",[_._v("这一方向上没有数据流动")]),_._v("。一个 TCP 连接在收到一个 FIN 后仍能发送数据，首先进行关闭的一方将执行"),a("code",[_._v("主动关闭")]),_._v("，而另一方执行"),a("code",[_._v("被动关闭")]),_._v("。")]),_._v(" "),a("p",[a("img",{attrs:{src:t(153),alt:"TCP四次挥手"}})]),_._v(" "),a("h3",{attrs:{id:"第一次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一次挥手"}},[_._v("#")]),_._v(" 第一次挥手")]),_._v(" "),a("p",[_._v("客户端主动向服务端发出"),a("code",[_._v("断开 TCP 连接")]),_._v("的请求报文，将报文"),a("code",[_._v("终止标志位 FIN 设置为1")]),_._v("，表示要释放 TCP 连接，并进入"),a("code",[_._v("等待结束连接状态FIN_WAIT-1")]),_._v(" 。"),a("code",[_._v("（报文首部：FIN=1，序号 seq=u（u为随机数））")])]),_._v(" "),a("h3",{attrs:{id:"第二次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二次挥手"}},[_._v("#")]),_._v(" 第二次挥手")]),_._v(" "),a("p",[_._v("服务端收到客户端的释放连接请求后，回复确认报文给客户端，将报文"),a("code",[_._v("确认标志位 ACK 设置为1")]),_._v("，表示已收到客户端请求，"),a("code",[_._v("关闭服务端读通道")]),_._v("并进入"),a("code",[_._v("关闭等待状态 CLOSE-WAIT")]),_._v("。"),a("code",[_._v("（报文首部：ACK=1，确认号 ack=u+1（收到的序号+1），序号 seq=v（v为随机数））")])]),_._v(" "),a("p",[_._v("客户端收到确认报文后，会"),a("code",[_._v("关闭客户端写通道")]),_._v("，此时客户端仍能通过读通道读取服务端的数据，服务器仍能通过写通道写数据。")]),_._v(" "),a("h3",{attrs:{id:"第三次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三次挥手"}},[_._v("#")]),_._v(" 第三次挥手")]),_._v(" "),a("p",[_._v("服务端发送"),a("code",[_._v("断开 TCP 连接")]),_._v("的请求报文，将报文"),a("code",[_._v("终止标志位 FIN 设置为1")]),_._v("。表示服务端数据已发送完毕，要释放连接，不会再发送任何数据了。"),a("code",[_._v("（报文首部：FIN=1，ACK=1，确认号 ack=u+1（收到的序号+1），序号 seq=w（w为随机数））")])]),_._v(" "),a("h3",{attrs:{id:"第四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第四次挥手"}},[_._v("#")]),_._v(" 第四次挥手")]),_._v(" "),a("p",[_._v("客户端收到服务端的断开连接请求后，回复确认报文，将报文"),a("code",[_._v("确认标志位 ACK 设置为1")]),_._v("，"),a("code",[_._v("关闭客户端读通道")]),_._v("，服务端收到客户端的"),a("code",[_._v("确认报文")]),_._v("后，"),a("code",[_._v("关闭服务端读通道")]),_._v("。双方读写通道全部关闭，完成四次挥手。"),a("code",[_._v("（报文首部：ACK=1，确认号 ack=w+1（收到的序号+1），序号 seq=u+1（服务端传过来的ack的值））")])]),_._v(" "),a("h2",{attrs:{id:"状态概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态概述"}},[_._v("#")]),_._v(" 状态概述")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("LISTEN：侦听来自远方TCP端口的连接请求")])]),_._v(" "),a("li",[a("p",[_._v("SYN-SENT：在发送连接请求后等待匹配的连接请求")])]),_._v(" "),a("li",[a("p",[_._v("SYN-RECEIVED：在收到和发送一个连接请求后等待对连接请求的确认")])]),_._v(" "),a("li",[a("p",[_._v("ESTABLISHED：代表一个打开的连接，数据可以传送给用户")])]),_._v(" "),a("li",[a("p",[_._v("FIN-WAIT-1：等待远程TCP的连接中断请求，或先前的连接中断请求的确认")])]),_._v(" "),a("li",[a("p",[_._v("FIN-WAIT-2：从远程TCP等待连接中断请求")])]),_._v(" "),a("li",[a("p",[_._v("CLOSE-WAIT：等待从本地用户发来的连接中断请求")])]),_._v(" "),a("li",[a("p",[_._v("CLOSING：等待远程TCP对连接中断的确认")])]),_._v(" "),a("li",[a("p",[_._v("LAST-ACK：等待原来发向远程TCP的连接中断请求的确认")])]),_._v(" "),a("li",[a("p",[_._v("TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认")])]),_._v(" "),a("li",[a("p",[_._v("CLOSED：没有任何连接状态")])])]),_._v(" "),a("h2",{attrs:{id:"几个疑问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#几个疑问"}},[_._v("#")]),_._v(" 几个疑问")]),_._v(" "),a("h3",{attrs:{id:"为什么要三次握手而不是两次握手？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要三次握手而不是两次握手？"}},[_._v("#")]),_._v(" 为什么要三次握手而不是两次握手？")]),_._v(" "),a("p",[_._v("为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。")]),_._v(" "),a("h3",{attrs:{id:"_2msl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2msl"}},[_._v("#")]),_._v(" 2MSL")]),_._v(" "),a("p",[_._v("在结束连接的过程中，为什么在收到服务器端的连接释放报文段之后，客户端还要继续等待2MSL之后才真正关闭TCP连接呢？")]),_._v(" "),a("p",[_._v("这里有两个原因：")]),_._v(" "),a("p",[_._v("第一个是：需要保证服务器端收到了客户端的最后一条确认报文。假如这条报文丢失，服务器没有接收到确认报文，就会对连接释放报文进行超时重传，而此时客户端连接已关闭，无法做出响应，就造成了服务器端不停重传连接释放报文，而无法正常进入关闭状态的状况。而等待2MSL，就可以保证服务器端收到了最终确认；若服务器端没有收到，那么在2MSL之内客户端一定会收到服务器端的重传报文，此时客户端就会重传确认报文，并重置计时器。")]),_._v(" "),a("p",[_._v("第二个是：存在一种“已失效的连接请求报文段”，需要避免这种报文端出现在本连接中，造成异常。这种“已失效的连接请求报文段”是这么形成的：假如客户端发出了连接请求报文，然而服务器端没有收到，于是客户端进行超时重传，再一次发送了连接请求报文，并成功建立连接。然而，第一次发送的连接请求报文并没有丢失，只是在某个网络结点中发生了长时间滞留，随后，这个最初发送的报文段到达服务器端，会使得服务器端误以为客户端发出了新的请求，造成异常。")]),_._v(" "),a("h2",{attrs:{id:"资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[_._v("#")]),_._v(" 资料")]),_._v(" "),a("p",[_._v("🍃 资料1："),a("a",{attrs:{href:"https://kuaibao.qq.com/s/20180627G0I4VO00?refer=cp_1026",target:"_blank",rel:"noopener noreferrer"}},[_._v("史上最容易理解的：TCP三次握手，四次挥手"),a("OutboundLink")],1)]),_._v(" "),a("p",[_._v("🍃 资料2："),a("a",{attrs:{href:"https://www.jianshu.com/p/c9d245aa722a",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP三次握手原理"),a("OutboundLink")],1)]),_._v(" "),a("p",[_._v("🍃 资料3："),a("a",{attrs:{href:"https://zixuephp.net/article-428.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP的三次握手(建立连接）和四次挥手(关闭连接）"),a("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);