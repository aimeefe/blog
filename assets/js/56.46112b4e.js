(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{239:function(n,e,a){"use strict";a.r(e);var t=a(0),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"装饰者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式"}},[n._v("#")]),n._v(" 装饰者模式")]),n._v(" "),a("p",[n._v("装饰者模式是在不改变其原有结构和功能的基础上，给对象动态的增加新的功能。")]),n._v(" "),a("h2",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[n._v("#")]),n._v(" 特点")]),n._v(" "),a("p",[n._v("装饰者模式将一个对象嵌入另一个对象之中，形成一条包装链。请求随着这条链依次传递到所有对象，使每个对象都有处理这条请求的机会。")]),n._v(" "),a("h2",{attrs:{id:"装饰者模式-vs-适配器模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式-vs-适配器模式"}},[n._v("#")]),n._v(" 装饰者模式 VS 适配器模式")]),n._v(" "),a("p",[n._v("两者都是通过封装对象来实现设计的目的，区别在于：")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("适配器模式：由于数据格式等原因导致代码无法使用了，需要适配器转换成可用代码，比如电源适配器等。")])]),n._v(" "),a("li",[a("p",[n._v("装饰者模式：原有功能在正常使用，只是在原有功能的基础上再装饰一下使其更完美，比如手机壳等。")])])]),n._v(" "),a("h2",{attrs:{id:"面向对象中的装饰者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象中的装饰者"}},[n._v("#")]),n._v(" 面向对象中的装饰者")]),n._v(" "),a("h6",{attrs:{id:"demo01-飞机大战游戏中，随着经验值的增加，飞机也升级成了更厉害的飞机，一开始这些飞机只能发射普通子弹，升到第二级时发射导弹，第三级时可以发射原子弹"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#demo01-飞机大战游戏中，随着经验值的增加，飞机也升级成了更厉害的飞机，一开始这些飞机只能发射普通子弹，升到第二级时发射导弹，第三级时可以发射原子弹"}},[n._v("#")]),n._v(" demo01 飞机大战游戏中，随着经验值的增加，飞机也升级成了更厉害的飞机，一开始这些飞机只能发射普通子弹，升到第二级时发射导弹，第三级时可以发射原子弹")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 原始\nvar Plane = function () {}\nPlane.prototype.fire = function () {\n  console.log('发射普通子弹');\n}\n\n// 添加装饰\nvar MissileDecorator = function (plane) {\n  this.plane = plane;\n}\nMissileDecorator.prototype.fire = function () {\n  this.plane.fire();\n  console.log('发射导弹');\n}\n\nvar AtomDecorator = function (plane) {\n  this.plane = plane;\n}\nAtomDecorator.prototype.fire = function () {\n  this.plane.fire();\n  console.log('发射原子弹');\n}\n")])])]),a("p",[n._v("测试：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var plane = new Plane();\nplane = new MissileDecorator(plane);\nplane = new AtomDecorator(plane);\nplane.fire(); // 依次输出：发射普通子弹，发射导弹，发射原子弹\n")])])]),a("blockquote",[a("p",[n._v("分析:")]),n._v(" "),a("p",[n._v("导弹类和原子弹类的构造函数都接受参数 plane 对象，并且保存好这个参数，在他们的 fire 方法中，除了执行自身的操作之外，还调用 plane 对象的 fire 方法。")]),n._v(" "),a("p",[n._v("这种给对象动态增加职责的方式，并没有真正改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象，这些对象都拥有相同接口（fire），当请求达到链中的某个对象时，这个对象会执行自身操作，随后把请求发给链中的下一个对象。")])]),n._v(" "),a("h2",{attrs:{id:"javascript-的装饰者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的装饰者"}},[n._v("#")]),n._v(" JavaScript 的装饰者")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 原始\nconst plane = {\n  fire: () => {\n    console.log('发射普通子弹');\n  }\n}\n\nconst missileDecorator = () => {\n  console.log('发射导弹');\n}\n\nconst atomDecorator = () => {\n  console.log('发射原子弹');\n}\n\nconst fire1 = plane.fire;\nplane.fire = () => {\n  fire1();\n  missileDecorator();\n}\n\nconst fire2 = plane.fire;\nplane.fire = () => {\n  fire2();\n  atomDecorator();\n}\nplane.fire(); //依次输出：发射普通子弹，发射导弹，发射原子弹\n")])])]),a("h2",{attrs:{id:"装饰函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装饰函数"}},[n._v("#")]),n._v(" 装饰函数")]),n._v(" "),a("p",[n._v("装饰者模式可以让我们在不改变函数源代码的情况下，给函数增加功能。")]),n._v(" "),a("p",[n._v("我们可以把行为依照职责分成粒度更细的函数，随后通过装饰者把它们合并在一起，有助于我们编写一个送耦合和高复用性的系统。")]),n._v(" "),a("h6",{attrs:{id:"demo01-登录功能：验证和发送请求隔离开来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#demo01-登录功能：验证和发送请求隔离开来"}},[n._v("#")]),n._v(" demo01 登录功能：验证和发送请求隔离开来")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 插件式表单验证：验证和提交隔离开来\n\nFunction.prototype.before = function (beforefn) {\n  var _self = this;\n  return function () {\n    if (beforefn.apply(this, arguments) === false) {\n      //beforefn 返回 false 的情况直接 return, 不再执行后面的原函数\n      return;\n    }\n    return _self.apply(this, arguments);\n  }\n}\n\nconst form = document.querySelector('#form');\n\n// 验证\nconst validata = function () {\n  if (!form.username.value) {\n    alert('name is required!');\n    return false;\n  }\n  if (!form.password.value) {\n    alert('password is required!');\n    return false;\n  }\n}\n\n\n// 原始\nvar formSubmit = function () {\n  var params = {\n    username: form.username.value,\n    password: form.password.value\n  }\n  console.log(params);\n  console.log('发送请求...');\n  // TODO 准备发送 post 请求\n  // Axios.post(...)\n}\n\n// 装饰者\nvar formSubmit = formSubmit.before(validata);\n\nform.addEventListener('submit', (e) => {\n  e.preventDefault();\n  formSubmit();\n})\n")])])]),a("blockquote",[a("p",[n._v("分析：")]),n._v(" "),a("p",[n._v("上例中，校验输入和提交表单完全分离开来，他们不再有任何耦合关系，formSubmit = formSubmit.before(validata) 这句代码，如同把校验规则动态接在 formSubmit 函数之前， validata 成为了一个即插即用的函数，它甚至可以写成配置文件的形式，这有利于我们分开维护这两个函数。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);